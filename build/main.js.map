{
  "version": 3,
  "sources": ["../src/main.ts"],
  "sourcesContent": ["/**\n * RadioHead adapter for ioBroker\n *\n * Copyright (c) 2019-2025 Peter M\u00FCller <peter@crycode.de>\n */\n\nimport * as utils from '@iobroker/adapter-core';\n\nimport { autobind } from 'core-decorators';\n\nimport { RadioHeadSerial, RH_ReceivedMessage as ReceivedMessage, version as RHS_VERSION } from 'radiohead-serial';\n\nimport { formatBufferAsHexString, hexNumber, parseAddress, parseNumber, round } from './lib/tools';\n\n// Augment the adapter.config object with the actual types\ndeclare global {\n  // eslint-disable-next-line @typescript-eslint/no-namespace\n  namespace ioBroker {\n    interface AdapterConfig {\n      port: string;\n      baud: string;\n      address: string;\n      reliable: boolean;\n      retries: number;\n      timeout: number;\n      promiscuous: boolean;\n      logAllData: boolean;\n    }\n  }\n}\n\nconst infoCounters: ('receivedCount' | 'retransmissionsCount' | 'sentErrorCount' | 'sentOkCount')[] = [ 'receivedCount', 'retransmissionsCount', 'sentErrorCount', 'sentOkCount' ];\n\nclass RadioheadAdapter extends utils.Adapter {\n\n  /**\n   * Address of this instance in the RadioHead network.\n   */\n  private address: number = 0x00;\n\n  /**\n   * Instance of the used RadioHeadSerial class\n   * or `null` if not initialized.\n   */\n  private rhs: RadioHeadSerial | null = null;\n\n  /**\n   * Counter for received RadioHead messages.\n   */\n  private receivedCount: number = 0;\n\n  /**\n   * Counter for retransmitted RadioHead messages.\n   */\n  private retransmissionsCount: number = 0;\n\n  /**\n   * Counter for falsy sent / not sent RadioHead messages.\n   */\n  private sentErrorCount: number = 0;\n\n  /**\n   * Counter for successfully sent RadioHead messages.\n   */\n  private sentOkCount: number = 0;\n\n  /**\n   * Internal storage for the retransmissions counter on instance start.\n   * Used to calculate the total retransmissions count.\n   */\n  private retransmissionsCountStart: number = 0;\n\n  /**\n   * Array of Objects for the incoming data matcher.\n   */\n  private incomingMatches: IncomingDataMatch[] = [];\n\n  /**\n   * Object containing a mapping of objectIDs and the data to send for\n   * outgoing data.\n   */\n  private outgoingMatches: Record<string, OutgoingDataMatch> = {};\n\n  /**\n   * If the serial port should be reopened on port close/errors.\n   * Will be set to false on adapter unload.\n   */\n  private reopenPortOnClose: boolean = true;\n\n  /**\n   * RHS init retry counter.\n   * Will be increased on each init retry and set to 0 on successfull init.\n   */\n  private rhsInitRetryCounter: number = 0;\n\n  /**\n   * Timeout for delayed init retry.\n   */\n  private rhsInitRetryTimeout: ioBroker.Timeout | undefined = undefined;\n\n  /**\n   * Constructor to create a new instance of the adapter.\n   * @param options The adapter options.\n   */\n  public constructor (options: Partial<utils.AdapterOptions> = {}) {\n    super({\n      ...options,\n      name: 'radiohead',\n    });\n\n    this.on('ready', this.onReady);\n    this.on('objectChange', this.onObjectChange);\n    this.on('stateChange', this.onStateChange);\n    this.on('message', this.onMessage);\n    this.on('unload', this.onUnload);\n  }\n\n  /**\n   * Is called when databases are connected and adapter received configuration.\n   */\n  @autobind\n  private async onReady (): Promise<void> {\n    // Reset the connection indicator during startup\n    await this.setState('info.connection', false, true);\n\n    // Debug log the RHS version\n    this.log.debug('RHS version: ' + RHS_VERSION);\n\n    // Debug log the current config\n    this.log.debug('config: ' + JSON.stringify(this.config));\n\n    // Parse and check the address of the adapter in the RadioHead network\n    this.address = parseNumber(this.config.address);\n    if (isNaN(this.address) || this.address < 0 || this.address > 254) {\n      this.log.error(`Config error: Invalid address ${this.config.address} (${this.address})!`);\n      return;\n    }\n\n    // Load/initialize the info counters\n    for (const id of infoCounters) {\n      const state = await this.getStateAsync('info.' + id);\n      this.log.debug(`loaded ${this.namespace}.info.${id} ` + JSON.stringify(state));\n      if (state) {\n        this[id] = state.val as number;\n      } else {\n        await this.setState('info.' + id, 0, true);\n      }\n    }\n\n    // setup matcher for incoming data\n    this.getForeignObjects(this.namespace + '.data.in.*', 'state', (err, objects) => {\n      if (err) {\n        this.log.error('Error loading incoming data objects');\n        return;\n      }\n\n      for (const objectId in objects) {\n        const obj: IncomingDataObject = objects[objectId] as IncomingDataObject;\n\n        const parts = obj.native.data.split(';');\n        parts.forEach((part, partIdx) => {\n          if (part.length === 0) {\n            this.log.warn(`Empty data part #${partIdx} in object ${objectId} ignored`);\n            return;\n          }\n          const data = part.trim().split(',');\n          const dataMatch: IncomingDataMatch = {\n            from: parseAddress(obj.native.fromAddress),\n            to: this.config.promiscuous ? parseAddress(obj.native.toAddress) : null,\n            data: this.prepareDataForMatcher(data),\n            objectId: objectId,\n            role: obj.common.role,\n            type: obj.common.type || 'number',\n            numParts: parts.length,\n            matchedPart: partIdx,\n            bufferDataType: obj.native.dataType,\n            bufferDataStart: data.indexOf('D'),\n            factor: obj.native.factor,\n            offset: obj.native.offset,\n            decimals: obj.native.decimals,\n          };\n          this.incomingMatches.push(dataMatch);\n        });\n      }\n\n      this.log.debug(`loaded ${this.incomingMatches.length} incoming matches`);\n    });\n\n    // setup mapping for outgoing data\n    this.getForeignObjects(this.namespace + '.data.out.*', 'state', (err, objects) => {\n      if (err) {\n        this.log.error('Error loading outgoing data objects');\n        return;\n      }\n\n      for (const objectId in objects) {\n        const obj: OutgoingDataObject = objects[objectId] as OutgoingDataObject;\n        const parts = obj.native.data.split(';').map((p) => p.trim().split(','));\n\n        const data: DataArray[] = [];\n        parts.forEach((part) => {\n          data.push(this.prepareDataForMatcher(part));\n        });\n\n        this.outgoingMatches[objectId] = {\n          to: parseAddress(obj.native.toAddress) ?? 0,\n          data: data.map((d) => Buffer.from(d as number[])),\n          role: obj.common.role,\n          type: obj.common.type || 'number',\n          bufferDataType: obj.native.dataType,\n          bufferDataStart: parts[0].indexOf('D'),\n        };\n      }\n\n      this.log.debug(`loaded ${Object.keys(this.outgoingMatches).length} outgoing matches`);\n    });\n\n    // set the start value for retransmissions counter\n    this.retransmissionsCountStart = this.retransmissionsCount;\n\n    // Init the radiohead-serial\n    await this.rhsInit();\n\n    // subscribe needed states\n    this.subscribeStates('actions.*');\n    this.subscribeStates('data.out.*');\n  }\n\n  /**\n   * Initialize the RadioHeadSerial instance and connect to the serial port.\n   *\n   * On first call this will create a new RHS instance and set it up.\n   * On next calls this will reinitialize the existing RHS instance to reinitialize the serial port.\n   */\n  private async rhsInit (): Promise<void> {\n    try {\n      // setup rhs instance only on first init\n      if (!this.rhs) {\n        this.rhs = new RadioHeadSerial({\n          port: this.config.port,\n          baud: parseInt(this.config.baud, 10),\n          address: this.address,\n          reliable: this.config.reliable,\n          autoInit: false,\n        });\n\n        this.rhs.on('error', this.onRhsError);\n        this.rhs.on('close', this.onRhsClose);\n        this.rhs.on('data', this.onRhsData);\n\n        // enable promiscuous mode if configured\n        if (this.config.promiscuous) {\n          this.rhs.setPromiscuous(true);\n          this.log.info('Promiscuous mode enabled');\n        }\n      }\n\n      // init of rhs instance may be called multiple times, e.g. when the port was closed\n      await this.rhs.init();\n\n      this.log.info('Manager initialized, my RadioHead address is ' + hexNumber(this.address));\n\n      // reset the retry counter\n      this.rhsInitRetryCounter = 0;\n\n      // set the connection state to connected\n      await this.setState('info.connection', true, true);\n\n    } catch (err) {\n      this.log.warn(`Error on serial port initialization: ${err}`);\n      this.rhsInitRetry();\n      return;\n    }\n  }\n\n  /**\n   * Start a RHS initialize retry.\n   *\n   * This will setup a timeout which will then call a RHS init.\n   * The timeout time depends on the retry counter.\n   */\n  private rhsInitRetry (): void {\n    // stop possible already existing timeout\n    if (this.rhsInitRetryTimeout) {\n      clearTimeout(this.rhsInitRetryTimeout);\n      this.rhsInitRetryTimeout = null;\n    }\n\n    // increase retry counter\n    this.rhsInitRetryCounter++;\n\n    // define timeout time in seconds to increase the time between the first 5 tries\n    let timeoutTime: number;\n    switch (this.rhsInitRetryCounter) {\n      case 1:\n        timeoutTime = 5;\n        break;\n      case 2:\n        timeoutTime = 10;\n        break;\n      case 3:\n        timeoutTime = 30;\n        break;\n      case 4:\n        timeoutTime = 60;\n        break;\n      default:\n        timeoutTime = 120;\n        break;\n    }\n\n    this.log.info(`Trying to reinitialize in ${timeoutTime}s (try #${this.rhsInitRetryCounter})`);\n\n    // set timeout to init again\n    this.rhsInitRetryTimeout = this.setTimeout(() => {\n      this.rhsInitRetryTimeout = null;\n      void this.rhsInit();\n    }, timeoutTime * 1000);\n  }\n\n  /**\n   * Is called when adapter shuts down - callback has to be called under any circumstances!\n   */\n  @autobind\n  private async onUnload (callback: () => void): Promise<void> {\n    try {\n      // don't reopen the port\n      this.reopenPortOnClose = false;\n\n      // clear possible reinitialize timeout\n      if (this.rhsInitRetryTimeout) {\n        this.clearTimeout(this.rhsInitRetryTimeout);\n        this.rhsInitRetryTimeout = null;\n      }\n\n      // close the serial port if rhs is initialized\n      if (this.rhs !== null) {\n        this.log.info('Closing serial port...');\n        try {\n          await this.rhs.close();\n        } catch (e) {\n          this.log.warn(`Error closing serial port: ${e}`);\n        }\n        this.rhs = null;\n      }\n\n      // reset connection state\n      await this.setState('info.connection', false, true);\n\n      callback();\n    } catch (_err) {\n      callback();\n    }\n  }\n\n  /**\n   * Handle RadioHeadSerial errors.\n   * @param error The error.\n   */\n  @autobind\n  private onRhsError (error: Error): void {\n    this.log.error(`RadioHeadSerial Error: ${error}`);\n  }\n\n  /**\n   * Handle RadioHeadSerial close events.\n   */\n  @autobind\n  private onRhsClose (): void {\n    void this.setState('info.connection', false, true);\n\n    // check if the port should be reopened\n    if (this.reopenPortOnClose) {\n      this.log.warn('Serial port closed');\n      this.rhsInitRetry();\n    } else {\n      // close was expected... just log an info\n      this.log.info('Serial port closed');\n    }\n  }\n\n  /**\n   * Prepare some data to be used with the matcher for incoming data.\n   * @param  data Array of strings for the data to match including placeholders * and D.\n   * @return      DataArray to be used with the matcher.\n   */\n  private prepareDataForMatcher (data: string[]): DataArray {\n    const newData: DataArray = [];\n    data.forEach((val, idx) => {\n      if (val === '*' || val === 'D') {\n        newData[idx] = null;\n      } else {\n        newData[idx] = parseNumber(val);\n      }\n    });\n\n    return newData;\n  }\n\n  /**\n   * Handler for incoming RadioHead messages.\n   * @param msg The received RadioHead message.\n   */\n  @autobind\n  private async onRhsData (msg: ReceivedMessage): Promise<void> {\n    await Promise.all([\n      this.setState('info.receivedCount', ++this.receivedCount, true),\n      this.setState('info.lastReceived', new Date().toISOString(), true),\n    ]);\n\n    // log data if enabled\n    if (this.config.logAllData) {\n      this.log.info(`Received <${formatBufferAsHexString(msg.data)}> from ${hexNumber(msg.headerFrom)} to ${hexNumber(msg.headerTo)} msgID ${hexNumber(msg.headerId)}`);\n    }\n\n    const data: DataArray = [ ...msg.data ]; // convert buffer to array\n\n    // set the msg as incoming data, replacing the data buffer by the array\n    await this.setState('data.incoming', { val: JSON.stringify({ ...msg, data }) }, true);\n\n    // check for matches\n    for (const dataMatch of this.incomingMatches) {\n      // filter addresses\n      if (msg.headerFrom !== dataMatch.from && dataMatch.from !== null) continue;\n      if (msg.headerTo !== dataMatch.to && dataMatch.to !== null) continue;\n\n      // check data\n      if (this.checkDataMatch(data, dataMatch.data)) {\n        // data matched!\n        this.log.debug(`received data ${JSON.stringify(msg)} matched ${JSON.stringify(dataMatch)}`);\n        await this.handleMatchedMessage(msg, dataMatch);\n      }\n    }\n  }\n\n  /**\n   * Handler for matched RadioHead messages.\n   * @param  msg       The RadioHead message.\n   * @param  dataMatch The matched incoming data.\n   * @return           Promise which will be resolved when the corresponding state is updated.\n   */\n  @autobind\n  private async handleMatchedMessage (msg: ReceivedMessage, dataMatch: IncomingDataMatch): Promise<void> {\n    switch (dataMatch.role) {\n      case 'button':\n        // buttons are pushed only\n        await this.setForeignStateAsync(dataMatch.objectId, true, true);\n        break;\n\n      case 'indicator':\n      case 'switch':\n        // switch and indicator can be set true/false or toggled\n        if (dataMatch.numParts === 1) {\n          // only one part... toggle\n          const oldState = await this.getForeignStateAsync(dataMatch.objectId);\n          await this.setForeignStateAsync(dataMatch.objectId, !(oldState?.val), true);\n        } else {\n          // two parts ... part 0 = true, part 1 = false\n          if (dataMatch.matchedPart === 0) {\n            await this.setForeignStateAsync(dataMatch.objectId, true, true);\n          } else {\n            await this.setForeignStateAsync(dataMatch.objectId, false, true);\n          }\n        }\n        break;\n\n      default: {\n        // check if data start is defined\n        if (dataMatch.bufferDataStart < 0) return;\n\n        // get the value and set the state\n        let val: number | boolean;\n        if (dataMatch.type === 'boolean') {\n          val = this.getValueFromBuffer(msg.data, 'uint8', dataMatch.bufferDataStart, dataMatch.objectId);\n          val = !!val; // make is boolean\n        } else { // number\n          val = this.getValueFromBuffer(msg.data, dataMatch.bufferDataType, dataMatch.bufferDataStart, dataMatch.objectId);\n          val = val * dataMatch.factor + dataMatch.offset;\n          if (typeof dataMatch.decimals === 'number') {\n            val = round(val, dataMatch.decimals);\n          }\n        }\n        await this.setForeignStateAsync(dataMatch.objectId, val, true);\n      }\n    }\n  }\n\n  /**\n   * Helper method to check if some received data matches a predefined data.\n   * @param  data    The data to check.\n   * @param  matchTo The data to match.\n   * @return         true is the data matches.\n   */\n  private checkDataMatch (data: DataArray, matchTo: DataArray): boolean {\n    // check length\n    if (matchTo.length === 0) return false;\n    if (data.length < matchTo.length) return false;\n    // loop through the bytes\n    const l = matchTo.length;\n    for (let idx = 0; idx < l; idx++) {\n      // continue if the byte should be ignored (is null)\n      if (matchTo[idx] === null) continue;\n\n      // check if the byte matches\n      if (matchTo[idx] !== data[idx]) {\n        // byte doesn't match\n        return false;\n      }\n    }\n\n    // all bytes matched\n    return true;\n  }\n\n  /**\n   * Update the counter of retransmissions.\n   * @return Promise which will be resolved when the state is set.\n   */\n  private async updateRetransmissionsCount (): Promise<void> {\n    if (!this.rhs) return;\n\n    const newRetr = this.retransmissionsCountStart + this.rhs.getRetransmissions();\n    if (newRetr !== this.retransmissionsCount) {\n      this.retransmissionsCount = this.retransmissionsCountStart + this.rhs.getRetransmissions();\n      await this.setState('info.retransmissionsCount', this.retransmissionsCount, true);\n    }\n  }\n\n  /**\n   * Helper method to get some value from a buffer.\n   * @param  buf      The buffer to read from.\n   * @param  type     The type of the value in the buffer.\n   * @param  start    Start index in the buffer where the value starts.\n   * @param  objectId ID of the object for which the value should be read.\n   * @return          The read value or NaN in case of an error.\n   */\n  private getValueFromBuffer (buf: Buffer, type: BufferDataType, start: number, objectId: string): number {\n    try {\n      switch (type) {\n        case 'int8': return buf.readInt8(start);\n        case 'uint8': return buf.readUInt8(start);\n        case 'int16_le': return buf.readInt16LE(start);\n        case 'int16_be': return buf.readInt16BE(start);\n        case 'uint16_le': return buf.readUInt16LE(start);\n        case 'uint16_be': return buf.readUInt16BE(start);\n        case 'int32_le': return buf.readInt32LE(start);\n        case 'int32_be': return buf.readInt32BE(start);\n        case 'uint32_le': return buf.readUInt32LE(start);\n        case 'uint32_be': return buf.readUInt32BE(start);\n        case 'float32_le': return buf.readFloatLE(start);\n        case 'float32_be': return buf.readFloatBE(start);\n        case 'double64_le': return buf.readDoubleLE(start);\n        case 'double64_be': return buf.readDoubleBE(start);\n        default:\n          this.log.warn(`${objectId} config error! Invalid data type ${type}`);\n      }\n    } catch (err) {\n      this.log.warn(`${objectId} config error! Maybe there are too few byte in the buffer to read a ${type}? ${err}`);\n    }\n    return NaN;\n  }\n\n  /**\n   * Helper method to write some value into a buffer.\n   * @param  val      The value to write.\n   * @param  buf      The buffer to write into.\n   * @param  type     The type of the value in the buffer.\n   * @param  start    Start index in the buffer where the value starts.\n   * @param  objectId ID of the object for which the value should be written.\n   * @return          true if the value is written successfully or false in case of an error.\n   */\n  private writeValueToBuffer (val: number, buf: Buffer, type: BufferDataType, start: number, objectId: string): boolean {\n    try {\n      switch (type) {\n        case 'int8':\n          buf.writeInt8(val, start);\n          break;\n        case 'uint8':\n          buf.writeUInt8(val, start);\n          break;\n        case 'int16_le':\n          buf.writeInt16LE(val, start);\n          break;\n        case 'int16_be':\n          buf.writeInt16BE(val, start);\n          break;\n        case 'uint16_le':\n          buf.writeUInt16LE(val, start);\n          break;\n        case 'uint16_be':\n          buf.writeUInt16BE(val, start);\n          break;\n        case 'int32_le':\n          buf.writeInt32LE(val, start);\n          break;\n        case 'int32_be':\n          buf.writeInt32BE(val, start);\n          break;\n        case 'uint32_le':\n          buf.writeUInt32LE(val, start);\n          break;\n        case 'uint32_be':\n          buf.writeUInt32BE(val, start);\n          break;\n        case 'float32_le':\n          buf.writeFloatLE(val, start);\n          break;\n        case 'float32_be':\n          buf.writeFloatBE(val, start);\n          break;\n        case 'double64_le':\n          buf.writeDoubleLE(val, start);\n          break;\n        case 'double64_be':\n          buf.writeDoubleBE(val, start);\n          break;\n        default:\n          this.log.warn(`${objectId} config error! Invalid data type ${type}`);\n          return false;\n      }\n    } catch (err) {\n      this.log.warn(`${objectId} config error! Maybe there are too few byte in the buffer to write a ${type}? ${err}`);\n      return false;\n    }\n    return true;\n  }\n\n  /**\n   * Is called if a subscribed object changes.\n   * @param id  The ID of the object.\n   * @param obj The ioBroker object.\n   */\n  @autobind\n  private onObjectChange (id: string, obj: ioBroker.Object | null | undefined): void {\n    if (obj) {\n      // The object was changed\n      this.log.debug(`object ${id} changed: ${JSON.stringify(obj)}`);\n    } else {\n      // The object was deleted\n      this.log.debug(`object ${id} deleted`);\n    }\n  }\n\n  /**\n   * Is called if a subscribed state changes.\n   * @param id    The ID of the state.\n   * @param state The ioBroker state.\n   */\n  @autobind\n  private async onStateChange (id: string, state: ioBroker.State | null | undefined): Promise<void> {\n    if (state) {\n      // The state was changed\n      this.log.debug(`state ${id} changed: ${state.val} (ack = ${state.ack}) ` + JSON.stringify(state));\n\n      // don't do anything if ack is set\n      // we aren't able to send something if rhs is not initialized\n      if (state.ack === true || !this.rhs) return;\n\n      // handle special states\n      // eslint-disable-next-line @typescript-eslint/switch-exhaustiveness-check\n      switch (id) {\n        case this.namespace + '.actions.resetCounters':\n          this.log.info('Reset information counters');\n\n          this.retransmissionsCountStart = 0;\n          this.rhs.resetRetransmissions();\n\n          for (const infoCounterId of infoCounters) {\n            this[infoCounterId] = 0;\n            await this.setState('info.' + infoCounterId, 0, true);\n          }\n\n          await this.setState(id, state, true);\n          return;\n      }\n\n      // is this some outgoing data?\n      if (Object.prototype.hasOwnProperty.call(this.outgoingMatches, id)) {\n        // prepare the data for sending\n        let buf: Buffer | null = null;\n        switch (this.outgoingMatches[id].role) {\n          case 'switch':\n          case 'indicator':\n            // switch or indicator uses the second data group for false value if provied\n            if (this.outgoingMatches[id].data.length > 1 && !state.val) {\n              // send false\n              buf = Buffer.from(this.outgoingMatches[id].data[1]); // copy the configured buffer to prevent issues\n              break;\n            }\n\n          // eslint-disable-next-line no-fallthrough\n          default:\n            buf = Buffer.from(this.outgoingMatches[id].data[0]); // copy the configured buffer to prevent issues\n        }\n\n        // if there is a data start defined ...\n        if (this.outgoingMatches[id].bufferDataStart >= 0) {\n          if (this.outgoingMatches[id].type === 'boolean') {\n            // boolean type values is always 0x01 (true) or 0x00 (false)\n            buf[this.outgoingMatches[id].bufferDataStart] = (state.val) ? 0x01 : 0x00;\n          } else {\n            // write the value into the buffer\n            if (!this.writeValueToBuffer(state.val as number, buf, this.outgoingMatches[id].bufferDataType, this.outgoingMatches[id].bufferDataStart, id)) {\n              return;\n            }\n          }\n        }\n\n        // send the data\n        await this.rhsSend(this.outgoingMatches[id].to, buf, id, state);\n      }\n    } else {\n      // The state was deleted\n      this.log.debug(`state ${id} deleted`);\n    }\n  }\n\n  /**\n   * Method to send some data using RadioHead.\n   * @param  to              Address of the receiver.\n   * @param  buf             The data to send as a buffer.\n   * @param  sendingObjectId ID of the ioBroker object which triggered the sending.\n   * @param  stateAck        ioBroker state so set the ack on when sent successfully.\n   * @return                 A Promise which will be resolved when done. If there was an error the first argument will be the error.\n   */\n  @autobind\n  private async rhsSend (to: number, buf: Buffer, sendingObjectId: string, stateAck?: ioBroker.State): Promise<Error | undefined> {\n    if (!this.rhs?.isInitDone()) {\n      this.log.warn(`Unable to send new value of '${sendingObjectId}' because we are not ready to send`);\n      return new Error('Unable to send, not ready');\n    }\n\n    if (this.config.logAllData) {\n      this.log.info(`Sending <${formatBufferAsHexString(buf)}> to ${hexNumber(to)}`);\n    }\n\n    let err: Error | undefined;\n    await this.rhs.send(to, buf)\n      .then(() => {\n        // update ok info\n        void this.setState('info.sentOkCount', ++this.sentOkCount, true);\n        void this.setState('info.lastSentOk', new Date().toISOString(), true);\n\n        // set the ack flag\n        if (stateAck) {\n          void this.setState(sendingObjectId, stateAck, true);\n        }\n      })\n      .catch((e) => {\n        // update error info\n        void this.setState('info.sentErrorCount', ++this.sentErrorCount, true);\n        void this.setState('info.lastSentError', new Date().toISOString(), true);\n        this.log.warn(`Error sending message for ${sendingObjectId} to ${hexNumber(to)} - ${e}`);\n        err = e as Error;\n      })\n      // in any case update the retransmissions counter\n      .then(() => this.updateRetransmissionsCount());\n\n    return err;\n  }\n\n  /**\n   * Some message was sent to this instance over message box (e.g. by a script).\n   * @param obj The received ioBroker message.\n   */\n  @autobind\n  private onMessage (obj: ioBroker.Message): void {\n    this.log.debug('got message ' + JSON.stringify(obj));\n\n    if (typeof obj === 'object' && obj.message) {\n      if (obj.command === 'send') {\n        // we should send some message...\n        if (typeof obj.message !== 'object') {\n          this.log.warn(`Invalid send message from ${obj.from} received ` + JSON.stringify(obj.message));\n          return;\n        }\n\n        const payload: MessagePayloadSend = obj.message as MessagePayloadSend;\n        const to = parseAddress(payload.to);\n\n        let buf: Buffer | null;\n        try {\n          buf = Buffer.from(payload.data as []);\n        } catch (_err) {\n          buf = null;\n        }\n\n        if (to === null || buf === null || buf.length === 0) {\n          this.log.warn(`Invalid send message from ${obj.from} received ` + JSON.stringify(obj.message));\n          return;\n        }\n\n        void this.rhsSend(to, buf, obj.from)\n          .then((error) => {\n            // Send response in callback if required\n            if (obj.callback) {\n              this.sendTo(obj.from, obj.command, { error: error }, obj.callback);\n            }\n          });\n      }\n    }\n  }\n\n}\n\nif (require.main !== module) {\n  // Export the constructor in compact mode\n  module.exports = (options: Partial<utils.AdapterOptions> | undefined) => new RadioheadAdapter(options);\n} else {\n  // otherwise start the instance directly\n  (() => new RadioheadAdapter())();\n}\n"],
  "mappings": "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",
  "names": ["RHS_VERSION"]
}
